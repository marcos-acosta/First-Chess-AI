var Engine = function (initDepth, initGame) {
    //RATIO OF MATERIAL VALUE TO POSITIONAL WEIGHT
    var MATERIAL_SCALE = 5;
    
    //POSITIONAL VALUES FOR EACH PIECE TYPE
    var KING_POSITIONS = [
        [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
        [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
        [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
        [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
        [-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0],
        [-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0],
        [2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0],
        [2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0],
    ];

    var QUEEN_POSITIONS = [
        [-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],
        [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],
        [-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0],
        [-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5],
        [0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5],
        [-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0],
        [-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0],
        [-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],
    ];

    var ROOK_POSITIONS = [
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
        [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
        [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
        [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
        [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
        [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
        [0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0],
    ];

    var BISHOP_POSITIONS = [
        [- 2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],
        [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],
        [-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0],
        [-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0],
        [-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0],
        [-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0],
        [-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0],
        [-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],
    ];

    var KNIGHT_POSITIONS = [
        [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],
        [-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0],
        [-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0],
        [- 3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0],
        [-3.0, 0.0, 1.0, 2.0, 2.0, 1.0, 0.0, -3.0],
        [-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0],
        [-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0],
        [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],
    ];

    var PAWN_POSITIONS = [
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0],
        [1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0],
        [0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5],
        [0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0],
        [0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5],
        [0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    ];

    var depth = initDepth;
    var game = initGame;
    
    //PIECE RAW VALUES
    const PAWN_VALUE = 1;
    const KNIGHT_VALUE = 3.5;
    const BISHOP_VALUE = 3.5;
    const ROOK_VALUE = 5.25;
    const QUEEN_VALUE = 10;
    const KING_VALUE = 999;

    //Perform minimax and alpha-beta pruning on a search tree of depth d
    function minimax(root, d, alpha, beta, maximizingPlayer) {
        var allMoves = root.simple_moves();
        var eval;
        var maxEval;
        var minEval;
        var i;
        var bestMoveIndex = -1;
        var bestMoveValue;
        //If depth is 0 or game is over, return static evaluation
        if (d === 0 || root.game_over()) {
            return evaluate(root);
        }
        //If white
        if (maximizingPlayer === true) {
            bestMoveValue = -Infinity;
            maxEval = -Infinity;
            for (i = 0; i < allMoves.length; i++) {
                eval = minimax(root.copy_of().move(allMoves[i]), d - 1, alpha, beta, false);
                //If this is one of the AI's initial move options
                if (d === depth) {
                    if (eval > bestMoveValue) {
                        bestMoveValue = eval;
                        bestMoveIndex = i;
                    }
                }
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            if (d === depth) {
                return bestMoveIndex;
            } else {
                return maxEval;
            }
        }
        //If black
        else {
            bestMoveValue = Infinity;
            minEval = Infinity;
            for (i = 0; i < allMoves.length; i++) {
                eval = minimax(root.copy_of().move(allMoves[i]), d - 1, alpha, beta, true);
                //If this is one of the AI's initial move options
                if (d === depth) {
                    if (eval < bestMoveValue) {
                        bestMoveValue = eval;
                        bestMoveIndex = i;
                    }
                }
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            if (d === depth) {
                return bestMoveIndex;
            } else {
                return minEval;
            }
        }
    }

    //Returns the evaluation of a board, considering checkmate and stalemate
    function evaluate(board) {
        if (board.in_checkmate() === true) {
            if (board.turn() == 'w') {
                return -Infinity;
            } else {
                return Infinity;
            }
        }
        if (board.in_checkmate() === false && board.game_over === true){
            return 0;
        }

        // Do a positional evaluation
        return positional_evaluation(board);
    }

    //Evaluates the current board using piece values and positional weight
    function positional_evaluation(board) {
        var eval = 0;
        var letters = 'abcdefgh';
        var square;
        for (var i = 0; i < 8; i++) {
            for (var j = 1; j < 9; j++) {
                square = board.get(letters.substring(i, i + 1) + j);
                if (square != null) {
                    if (square.color === 'w') {
                        if (square.type === 'r') {
                            eval += ROOK_VALUE + ROOK_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        } else if (square.type === 'n') {
                            eval += KNIGHT_VALUE + KNIGHT_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        } else if (square.type === 'b') {
                            eval += BISHOP_VALUE + BISHOP_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        } else if (square.type === 'q') {
                            eval += QUEEN_VALUE + QUEEN_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        } else if (square.type === 'k') {
                            eval += KING_VALUE + KING_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        } else {
                            eval += PAWN_VALUE + PAWN_POSITIONS[8 - j][i] / MATERIAL_SCALE;
                        }
                    } else {
                        if (square.type === 'r') {
                            eval -= (ROOK_VALUE + ROOK_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        } else if (square.type === 'n') {
                            eval -= (KNIGHT_VALUE + KNIGHT_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        } else if (square.type === 'b') {
                            eval -= (BISHOP_VALUE + BISHOP_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        } else if (square.type === 'q') {
                            eval -= (QUEEN_VALUE + QUEEN_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        } else if (square.type === 'k') {
                            eval -= (KING_VALUE + KING_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        } else {
                            eval -= (PAWN_VALUE + PAWN_POSITIONS[j - 1][7 - i] / MATERIAL_SCALE);
                        }
                    }
                }
            }
        }
        return eval;
    }

    //If there are commonly accepted responses to white, play one of them (else return null)
    function book_moves(board) {
        var fen = board.fen();
        var pos = fen.substring(0, fen.search(' '));
        var rand;
        var good_moves;
        //King's pawn
        if (pos === 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR') {
            good_moves = ['e5', 'c5', 'e6', 'd6'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //Queen's pawn
        else if (pos === 'rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR') {
            good_moves = ['Nf6', 'd5', 'd6', 'e6'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //Reti
        else if (pos === 'rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R'){
            good_moves = ['Nf6', 'd5', 'c5', 'g6'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //English
        else if (pos === 'rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR'){
            good_moves = ['Nf6', 'e5', 'e6', 'c5'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //C40: King's pawn
        else if (pos === 'rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R'){
            good_moves = ['Nc6', 'd6'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //B27 Sicilian
        else if (pos === 'rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R'){
            good_moves = ['d6', 'Nc6', 'e6'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        //C00 French defence
        else if (pos === 'rnbqkbnr/pppp1ppp/4p3/8/3PP3/8/PPP2PPP/RNBQKBNR'){
            good_moves = ['d5', 'c5'];
            rand = Math.floor(Math.random() * good_moves.length);
            return good_moves[rand];
        }
        else {
            return null;
        }
    }

    //API
    return {
        //Debug
        printPossibleMoves: function () {
            var possibleMoves = game.moves();
            var str = "";
            var i;
            for (i = 0; i < possibleMoves.length; i++) {
                str = str.concat(possibleMoves[i] + " ");
            }
            return str;
        },

        //Select the best move found via minimax
        pickBestMove: function () {
            var book_move = book_moves(game);
            if (book_move != null) {
                return book_move;
            } else {
                return game.simple_moves()[minimax(game, depth, -Infinity, Infinity, false)];
            }
        },
    }
};